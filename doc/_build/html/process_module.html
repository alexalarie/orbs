<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Process module &mdash; Orbs 3.8.1 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.8.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/logo.ico"/>
    <link rel="top" title="Orbs 3.8.1 documentation" href="index.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="Orbs module" href="orbs_module.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Changelog"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="orbs_module.html" title="Orbs module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Orbs 3.8.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Process module</a><ul>
<li><a class="reference internal" href="#rawdata-class">RawData class</a></li>
<li><a class="reference internal" href="#interferogram-class">Interferogram class</a></li>
<li><a class="reference internal" href="#interferogrammerger-class">InterferogramMerger class</a></li>
<li><a class="reference internal" href="#calibrationlaser-class">CalibrationLaser class</a></li>
<li><a class="reference internal" href="#spectrum-class">Spectrum class</a></li>
<li><a class="reference internal" href="#phase-class">Phase class</a></li>
<li><a class="reference internal" href="#standard-class">Standard class</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="orbs_module.html"
                        title="previous chapter">Orbs module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="changelog.html"
                        title="next chapter">Changelog</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/process_module.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="process-module">
<h1><a class="toc-backref" href="#id1">Process module</a><a class="headerlink" href="#process-module" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#process-module" id="id1">Process module</a><ul>
<li><a class="reference internal" href="#rawdata-class" id="id2">RawData class</a></li>
<li><a class="reference internal" href="#interferogram-class" id="id3">Interferogram class</a></li>
<li><a class="reference internal" href="#interferogrammerger-class" id="id4">InterferogramMerger class</a></li>
<li><a class="reference internal" href="#calibrationlaser-class" id="id5">CalibrationLaser class</a></li>
<li><a class="reference internal" href="#spectrum-class" id="id6">Spectrum class</a></li>
<li><a class="reference internal" href="#phase-class" id="id7">Phase class</a></li>
<li><a class="reference internal" href="#standard-class" id="id8">Standard class</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="rawdata-class">
<h2><a class="toc-backref" href="#id2">RawData class</a><a class="headerlink" href="#rawdata-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.RawData">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">RawData</tt><big>(</big><em>image_list_path</em>, <em>image_mode='classic'</em>, <em>chip_index=1</em>, <em>binning=1</em>, <em>data_prefix='temp_data_'</em>, <em>config_file_name='config.orb'</em>, <em>project_header=[]</em>, <em>wcs_header=[]</em>, <em>calibration_laser_header=[]</em>, <em>overwrite=False</em>, <em>silent_init=False</em>, <em>no_log=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.RawData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Cube</span></tt></p>
<p>ORBS raw data processing class.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Raw data is the output data of SpIOMM/SITELLE without
any kind of processing.</p>
</div>
<dl class="method">
<dt id="process.RawData._get_alignment_vector_header">
<tt class="descname">_get_alignment_vector_header</tt><big>(</big><em>err=False</em><big>)</big><a class="headerlink" href="#process.RawData._get_alignment_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the alignment vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>err</strong> &#8211; (Optional) If True, the error vector header is
returned (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_alignment_vector_path">
<tt class="descname">_get_alignment_vector_path</tt><big>(</big><em>err=False</em><big>)</big><a class="headerlink" href="#process.RawData._get_alignment_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the alignment vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>err</strong> &#8211; (Optional) If True, the error vector path is
returned (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_cr_map_frame_header">
<tt class="descname">_get_cr_map_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_cr_map_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the cosmic ray map.</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_cr_map_frame_path">
<tt class="descname">_get_cr_map_frame_path</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#process.RawData._get_cr_map_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to a frame of the cosmic ray map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> &#8211; Index of the frame</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_cr_map_list_path">
<tt class="descname">_get_cr_map_list_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_cr_map_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return  the default path to the cosmic ray map list</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_deep_frame_header">
<tt class="descname">_get_deep_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_deep_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the deep frame.</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_deep_frame_path">
<tt class="descname">_get_deep_frame_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_deep_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the deep frame.</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_energy_map_header">
<tt class="descname">_get_energy_map_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_energy_map_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the energy map.</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_energy_map_path">
<tt class="descname">_get_energy_map_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_energy_map_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the energy map.</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_hp_map_path">
<tt class="descname">_get_hp_map_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_hp_map_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the hot pixels map.</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_interfero_frame_header">
<tt class="descname">_get_interfero_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_interfero_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of an interferogram frame</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_interfero_frame_path">
<tt class="descname">_get_interfero_frame_path</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#process.RawData._get_interfero_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the interferogram frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> &#8211; The index of the interferogram frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_interfero_list_path">
<tt class="descname">_get_interfero_list_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.RawData._get_interfero_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the list of the interferogram
cube</p>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_master_header">
<tt class="descname">_get_master_header</tt><big>(</big><em>kind</em><big>)</big><a class="headerlink" href="#process.RawData._get_master_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of a master frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; Kind of master frame (e.g. : &#8216;bias&#8217;, &#8216;dark&#8217;,
&#8216;flat&#8217;)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._get_master_path">
<tt class="descname">_get_master_path</tt><big>(</big><em>kind</em><big>)</big><a class="headerlink" href="#process.RawData._get_master_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to a master frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> &#8211; Kind of master frame (e.g. : &#8216;bias&#8217;, &#8216;dark&#8217;,
&#8216;flat&#8217;)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._load_alignment_vector">
<tt class="descname">_load_alignment_vector</tt><big>(</big><em>alignment_vector_path</em><big>)</big><a class="headerlink" href="#process.RawData._load_alignment_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the alignment vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>alignment_vector_path</strong> &#8211; Path to the alignment vector file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData._load_bias">
<tt class="descname">_load_bias</tt><big>(</big><em>bias_list_path</em>, <em>return_temperature=False</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em><big>)</big><a class="headerlink" href="#process.RawData._load_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a master bias.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bias_list_path</strong> &#8211; Path to the list of bias frames</li>
<li><strong>return_temperature</strong> &#8211; If True return also the mean
temperature of the bias frames. Note that the header of the
files must have the keyword &#8216;CCD_TEMP&#8217;. Return None if the
temperatures could not be read.</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation. Can be
&#8216;sigclip&#8217;, &#8216;minmax&#8217;, &#8216;avsigclip&#8217; or None (default
&#8216;avsigclip&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Bias images are resized if x and y dimensions of the
flat images are not equal to the cube dimensions.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData._load_dark">
<tt class="descname">_load_dark</tt><big>(</big><em>dark_list_path</em>, <em>return_temperature=False</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em><big>)</big><a class="headerlink" href="#process.RawData._load_dark" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a master dark.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dark_list_path</strong> &#8211; Path to the list of dark frames</li>
<li><strong>return_temperature</strong> &#8211; If True return also the mean
temperature of the dark frames. Note that the header of the
files must have the keyword &#8216;CCD_TEMP&#8217;. Return None if the
temperatures could not be read.</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation. Can be
&#8216;sigclip&#8217;, &#8216;minmax&#8217;, &#8216;avsigclip&#8217; or None (default
&#8216;avsigclip&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Dark images are resized if x and y dimensions of the
flat images are not equal to the cube dimensions.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData._load_flat">
<tt class="descname">_load_flat</tt><big>(</big><em>flat_list_path</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>smooth_deg=0</em><big>)</big><a class="headerlink" href="#process.RawData._load_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a master flat.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>flat_list_path</strong> &#8211; Path to the list of flat frames</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation. Can be
&#8216;sigclip&#8217;, &#8216;minmax&#8217;, &#8216;avsigclip&#8217; or None (default
&#8216;avsigclip&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>smooth_deg</strong> &#8211; (Optional) If &gt; 0 smooth the master flat (help
removing possible fringe pattern) (default 0).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Flat images are resized if the x and y dimensions of
the flat images are not equal to the cube dimensions.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData.add_missing_frames">
<tt class="descname">add_missing_frames</tt><big>(</big><em>step_number</em><big>)</big><a class="headerlink" href="#process.RawData.add_missing_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Add non taken frames at the end of a cube in order to
complete it and have a centered ZDP. Useful when a cube could
not be completed during the night.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step_number</strong> &#8211; Number of steps for a full cube.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData.check_bad_frames">
<tt class="descname">check_bad_frames</tt><big>(</big><em>cr_map_list_path=None</em>, <em>coeff=2.0</em><big>)</big><a class="headerlink" href="#process.RawData.check_bad_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check an interferogram cube for bad frames.</p>
<p>If the number of detected cosmic rays is too important the
frame is considered as bad</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cr_map_path</strong> &#8211; (Optional) Path to the cosmic ray map</li>
<li><strong>coeff</strong> &#8211; (Optional) Threshold coefficient (Default 2.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData.correct">
<tt class="descname">correct</tt><big>(</big><em>bias_path=None</em>, <em>dark_path=None</em>, <em>flat_path=None</em>, <em>cr_map_list_path=None</em>, <em>alignment_vector_path=None</em>, <em>dark_int_time=None</em>, <em>flat_int_time=None</em>, <em>exposition_time=None</em>, <em>bad_frames_vector=[]</em>, <em>optimize_dark_coeff=False</em>, <em>dark_activation_energy=None</em>, <em>bias_calibration_params=None</em>, <em>negative_values=False</em>, <em>z_range=[]</em>, <em>order=1</em>, <em>zeros=False</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>flat_smooth_deg=0</em><big>)</big><a class="headerlink" href="#process.RawData.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct raw data for bias, dark, flat, cosmic rays and
alignment using the precomputed alignment vector and the
cosmic ray map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bias_path</strong> &#8211; (Optional) Path to a list of bias files. If
none given no correction is done.</li>
<li><strong>dark_path</strong> &#8211; (Optional) Path to a list of dark files. If
none given no dark and flat corrections are done.</li>
<li><strong>flat_path</strong> &#8211; (Optional) Path to a list of flat files. If
none given no flat correction is done.</li>
<li><strong>cr_map_list_path</strong> &#8211; (Optional) Path to the cosmic ray map
list of files, if none given the default path is used.</li>
<li><strong>alignment_vector_path</strong> &#8211; (Optional) Path to the alignment
vector file, if none given the default path is used.</li>
<li><strong>dark_int_time</strong> &#8211; (Optional) Integration time of the dark
frames. Used to remove the dark pattern from a flat with a
different integration time. User must specify flat_int_time.</li>
<li><strong>flat_int_time</strong> &#8211; (Optional) Integration time of the flat
frames. see dark_int_time.</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Contains the index of the
frames to be replaced by zeros.</li>
<li><strong>optimize_dark_coeff</strong> &#8211; (Optional) If True use a fast optimization
routine to calculate the best coefficient for dark
correction. This routine is used to correct for the images
of the camera 2 on SpIOMM, because it contains a lot of hot
pixels (Default False).</li>
<li><strong>dark_activation_energy</strong> &#8211; Activation energy in eV. This is a
calibration parameter used to guess the master dark
coefficient to apply in case the temperature of the frame is
different from the master dark temperature. Useful only if
optimize_dark_coeff is True and the temperature of the dark
frames and the interferogram frames is given in their header
[keyword &#8216;CCD-TEMP&#8217;] (Default None).</li>
<li><strong>bias_calibration_params</strong> &#8211; (Optional) a tuple of 2
parameters [a,b] that are used to compute the bias
coefficient for a varying temperature of the camera. Useful
only if optimize_dark_coeff is True and the temperature of
the bias frames and the interferogram frames is given in
their header [keyword &#8216;CCD-TEMP&#8217;] (Default None).</li>
<li><strong>exposition_time</strong> &#8211; (Optional) Integration time of the 
frames (can be defined in the option file).</li>
<li><strong>negative_values</strong> &#8211; (Optional) If False, replace negative values in
the calculated interferogram by zero (Default False).</li>
<li><strong>z_range</strong> &#8211; (Optional) 1d array containing the index of
the frames to be computed.</li>
<li><strong>order</strong> &#8211; (Optional) Interpolation order (Default 1). Be
careful in using an interpolation order greater than 1 with
images containing stars.</li>
<li><strong>zeros</strong> &#8211; (Optional) If True, cosmic rays are replaced by
zeros. If False, cosmic rays are replaced by the median of
the neighbouring region (default False).</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation for master
frames creation. Can be &#8216;sigclip&#8217;, &#8216;minmax&#8217;, &#8216;avsigclip&#8217; or
None (default &#8216;avsigclip&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation for master
frames creation. Can be &#8216;average&#8217; or &#8216;median&#8217; (default
&#8216;average&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>flat_smooth_deg</strong> &#8211; (Optional) If &gt; 0 smooth the master
flat (help removing possible fringe pattern) (default
0). See <a class="reference internal" href="#process.RawData._load_flat" title="process.RawData._load_flat"><tt class="xref py py-meth docutils literal"><span class="pre">process.RawData._load_flat()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Frames considered as bad (which index are in
<tt class="docutils literal"><span class="pre">bad_frames_vector</span></tt> or not in the <tt class="docutils literal"><span class="pre">z_range</span></tt> vector) are just
replaced by frames of zeros.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The creation of the corrected interferogram frames
walks through 2 steps:</p>
<ol class="last arabic simple">
<li>Correction for bias, dark, and flat field. Please refer
to: <a class="reference internal" href="#process.RawData.correct_frame" title="process.RawData.correct_frame"><tt class="xref py py-meth docutils literal"><span class="pre">process.RawData.correct_frame()</span></tt></a>.</li>
<li>Alignment of the frame using linear interpolation by
default. A higher order interpolation can be used if the
field contains no star like object. By default cosmic
rays are replaced by the weighted average of the
neighbouring region. Weights are computed from a gaussian
kernel.</li>
</ol>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#process.RawData.correct_frame" title="process.RawData.correct_frame"><tt class="xref py py-meth docutils literal"><span class="pre">process.RawData.correct_frame()</span></tt></a></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#process.RawData.create_cosmic_ray_map" title="process.RawData.create_cosmic_ray_map"><tt class="xref py py-meth docutils literal"><span class="pre">process.RawData.create_cosmic_ray_map()</span></tt></a></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#process.RawData.create_alignment_vector" title="process.RawData.create_alignment_vector"><tt class="xref py py-meth docutils literal"><span class="pre">process.RawData.create_alignment_vector()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData.correct_frame">
<tt class="descname">correct_frame</tt><big>(</big><em>index</em>, <em>master_bias</em>, <em>master_dark</em>, <em>master_flat</em>, <em>dark_int_time</em>, <em>flat_int_time</em>, <em>hp_map_path</em>, <em>optimize_dark_coeff</em>, <em>exposition_time</em>, <em>negative_values</em>, <em>master_dark_temp</em>, <em>master_bias_temp</em>, <em>dark_activation_energy</em>, <em>bias_calibration_params</em>, <em>master_bias_level</em>, <em>master_dark_level</em><big>)</big><a class="headerlink" href="#process.RawData.correct_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a frame for the bias, dark and flat field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>index</strong> &#8211; Index of the frame to be corrected</li>
<li><strong>master_bias</strong> &#8211; Master Bias (if None, no correction is done)</li>
<li><strong>master_dark</strong> &#8211; Master Dark. Must be in counts/s and bias
must have been removed. (if None, no dark and flat
corrections are done)</li>
<li><strong>master_flat</strong> &#8211; Master Flat (if None, no flat correction
is done)</li>
<li><strong>dark_int_time</strong> &#8211; Dark integration time</li>
<li><strong>flat_int_time</strong> &#8211; Flat integration time</li>
<li><strong>hp_map_path</strong> &#8211; Path to the hot pixel map</li>
<li><strong>optimize_dark_coeff</strong> &#8211; If True use a fast optimization
routine to calculate the best coefficient for dark
correction. This routine is used to correct for the images
of the camera 2 on SpIOMM, because it has a varying dark and
bias level and contains a lot of hot pixels (Default False).</li>
<li><strong>dark_activation_energy</strong> &#8211; Activation energy in eV. This
is a calibration parameter used to guess the master dark
coefficient to apply in case the temperature of the frame is
different from the master dark temperature. Useful only if
optimize_dark_coeff is True and the temperature of the dark
frames and the interferogram frames is given in their header
[keyword &#8216;CCD-TEMP&#8217;] (Default None).</li>
<li><strong>bias_calibration_params</strong> &#8211; A tuple of 2 parameters [a,b]
that are used to compute the bias coefficient for a varying
temperature of the camera. Useful only if
optimize_dark_coeff is True and the temperature of the bias
frames and the interferogram frames is given in their header
[keyword &#8216;CCD-TEMP&#8217;] (Default None).</li>
<li><strong>master_dark_temp</strong> &#8211; Mean temperature of the master dark
frame.</li>
<li><strong>master_bias_temp</strong> &#8211; Mean temperature of the master bias
frame.</li>
<li><strong>master_bias_level</strong> &#8211; Median level of the master bias frame.</li>
<li><strong>master_dark_level</strong> &#8211; Median level of the master dark frame.</li>
<li><strong>exposition_time</strong> &#8211; (Optional) Integration time of the 
frames (can be defined in the option file).</li>
<li><strong>negative_values</strong> &#8211; if False, replace negative values in
the calculated interferogram by zero.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The correction steps are:</p>
<ul class="last simple">
<li>(If optimize_dark_coeff is True) : Dark and bias levels
are corrected using calibrated functions and the level of
hot pixels are optimized by minimizing their standard
deviation.</li>
<li>Bias is substracted to dark and flat</li>
<li>Dark is substracted to flat if the integration 
time of the flat is given</li>
<li>Flat is normalized (median = 1)</li>
<li>The corrected image is calculated
<span class="math">\(frame=\frac{frame - dark + bias}{flat}\)</span>.</li>
<li>Negative values are set to 0 by default</li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData.create_alignment_vector">
<tt class="descname">create_alignment_vector</tt><big>(</big><em>star_list_path</em>, <em>init_fwhm_arc</em>, <em>fov</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em>, <em>min_coeff=0.3</em>, <em>readout_noise=10.0</em>, <em>dark_current_level=0.0</em><big>)</big><a class="headerlink" href="#process.RawData.create_alignment_vector" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Create the alignment vector used to compute the</dt>
<dd>interferogram from the raw images.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> &#8211; Path to a list of star coordinates that
will be used to calculates the displacement vector. Please
refer to <tt class="xref py py-meth docutils literal"><span class="pre">orb.astrometry.load_star_list()</span></tt> for more
information about a list of stars.</li>
<li><strong>init_fwhm_arc</strong> &#8211; Initial guess for the FWHM in arcsec</li>
<li><strong>fov</strong> &#8211; Field of View along x axis in arcmin</li>
<li><strong>profile_name</strong> &#8211; (Optional) PSF profile for star
fitting. Can be &#8216;moffat&#8217; or &#8216;gaussian&#8217;. See:
<tt class="xref py py-class docutils literal"><span class="pre">orb.astrometry.Astrometry</span></tt> (default &#8216;gaussian&#8217;).</li>
<li><strong>moffat_beta</strong> &#8211; (Optional) Beta parameter to use for
moffat PSF (default 3.5).</li>
<li><strong>min_coeff</strong> &#8211; (Optional) The minimum proportion of stars
correctly fitted to assume a good enough calculated
disalignment (default 0.3).</li>
<li><strong>readout_noise</strong> &#8211; (Optional) Readout noise in ADU/pixel
(can be computed from bias frames: std(master_bias_frame))
(default 10.)</li>
<li><strong>dark_current_level</strong> &#8211; (Optional) Dark current level in
ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The alignement vector contains the calculated
disalignment for each image along x and y axes to the first
image.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData.create_cosmic_ray_map">
<tt class="descname">create_cosmic_ray_map</tt><big>(</big><em>z_coeff=3.0</em>, <em>step_number=None</em>, <em>bad_frames_vector=[]</em>, <em>star_list_path=None</em>, <em>stars_fwhm_pix=2.0</em><big>)</big><a class="headerlink" href="#process.RawData.create_cosmic_ray_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the cosmic rays in the raw images and creates 
the cosmic ray map used to compute the interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>z_coeff</strong> &#8211; (Optional) Threshold coefficient for cosmic ray
detection, lower it to detect more cosmic rays (default : 3.).</li>
<li><strong>step_number</strong> &#8211; (Optional) &#8216;Full&#8217; number of steps if the
cube was complete. Might be different from the &#8216;real&#8217; number
of steps obtained. Helps in finding ZPD (default None).</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Contains the index of the
frames considered as bad(default []).</li>
<li><strong>star_list_path</strong> &#8211; (Optional) Path to a list of stars that
must be protected from over detection. All cosmic rays
detected in those stars will be removed.</li>
<li><strong>stars_fwhm_pix</strong> &#8211; (Optional) mean FWHM of the stars in
pixels.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A cosmic ray map is a &#8216;mask like&#8217; cube filled with
zeros and containing a one for each pixel identified as a
cosmic ray. This cube is stored as a virtual
<strong>frame-divided</strong> cube</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData.create_hot_pixel_map">
<tt class="descname">create_hot_pixel_map</tt><big>(</big><em>dark_image</em>, <em>bias_image</em><big>)</big><a class="headerlink" href="#process.RawData.create_hot_pixel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hot pixel map from a cube of dark frame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bias_image</strong> &#8211; Master bias frame (can be set to None)</li>
<li><strong>dark_image</strong> &#8211; Master dark frame</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A hot pixel map is a mask like frame (1 for a hot
pixel, 0 elsewhere)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.RawData.get_bias_coeff_from_T">
<tt class="descname">get_bias_coeff_from_T</tt><big>(</big><em>master_bias_temp</em>, <em>master_bias_level</em>, <em>frame_temp</em>, <em>calibrated_params</em><big>)</big><a class="headerlink" href="#process.RawData.get_bias_coeff_from_T" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>master_bias_temp</strong> &#8211; Temperature of the master bias frame.</li>
<li><strong>master_bias_level</strong> &#8211; Median of the master bias frame.</li>
<li><strong>frame_temp</strong> &#8211; Temperature of the frame to correct.</li>
<li><strong>calibrated_params</strong> &#8211; parameters [a, b] of the
function bias_level(T) = aT + b. T is in degrees C and
bias_level(T) is the median of the bias frame at the
given temperature.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData.get_dark_coeff_from_T">
<tt class="descname">get_dark_coeff_from_T</tt><big>(</big><em>master_dark_temp</em>, <em>master_dark_level</em>, <em>frame_temp</em>, <em>activation_energy</em><big>)</big><a class="headerlink" href="#process.RawData.get_dark_coeff_from_T" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Return calibrated coefficient of the calibrated dark frame
given the temperature of the frame to correct (see Widenhorn
et al. 2002)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>frame_temp</strong> &#8211; Temperature of the frame to correct.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Master_dark_level:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Master dark level in counts</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Master_dark_temp:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Master dark temperature in Celsius</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Activation_energy:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Activation energy in eV</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.RawData.get_noise_values">
<tt class="descname">get_noise_values</tt><big>(</big><em>bias_path</em>, <em>dark_path</em>, <em>exposition_time</em>, <em>dark_int_time</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em><big>)</big><a class="headerlink" href="#process.RawData.get_noise_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return readout noise and dark current level from bias and dark
frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bias_path</strong> &#8211; Path to a list of bias files.</li>
<li><strong>dark_path</strong> &#8211; Path to a list of dark files.</li>
<li><strong>exposition_time</strong> &#8211; Integration time of the frames.</li>
<li><strong>dark_int_time</strong> &#8211; Integration time of the dark frames.</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation for master
frames creation. Can be &#8216;sigclip&#8217;, &#8216;minmax&#8217;, &#8216;avsigclip&#8217; or
None (default &#8216;avsigclip&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation for master
frames creation. Can be &#8216;average&#8217; or &#8216;median&#8217; (default
&#8216;average&#8217;). See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.create_master_frame()</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">readout_noise, dark_current_level</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interferogram-class">
<h2><a class="toc-backref" href="#id3">Interferogram class</a><a class="headerlink" href="#interferogram-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.Interferogram">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">Interferogram</tt><big>(</big><em>image_list_path</em>, <em>image_mode='classic'</em>, <em>chip_index=1</em>, <em>binning=1</em>, <em>data_prefix='temp_data_'</em>, <em>config_file_name='config.orb'</em>, <em>project_header=[]</em>, <em>wcs_header=[]</em>, <em>calibration_laser_header=[]</em>, <em>overwrite=False</em>, <em>silent_init=False</em>, <em>no_log=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.Interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Cube</span></tt></p>
<p>ORBS interferogram processing class.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram data is defined as data already processed
(corrected and aligned frames) by <a class="reference internal" href="#process.RawData" title="process.RawData"><tt class="xref py py-class docutils literal"><span class="pre">process.RawData</span></tt></a> and
ready to be transformed to a spectrum by a Fast Fourier
Transform (FFT).</p>
</div>
<dl class="method">
<dt id="process.Interferogram._get_corrected_interferogram_frame_header">
<tt class="descname">_get_corrected_interferogram_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_corrected_interferogram_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of a corrected interferogram frame</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_corrected_interferogram_frame_path">
<tt class="descname">_get_corrected_interferogram_frame_path</tt><big>(</big><em>frame_index</em><big>)</big><a class="headerlink" href="#process.Interferogram._get_corrected_interferogram_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to a spectrum frame given its
index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>frame_index</strong> &#8211; Index of the frame</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_corrected_interferogram_list_path">
<tt class="descname">_get_corrected_interferogram_list_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_corrected_interferogram_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the corrected interferogram list</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_extracted_star_spectra_header">
<tt class="descname">_get_extracted_star_spectra_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_extracted_star_spectra_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header to the extracted star spectra</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_extracted_star_spectra_path">
<tt class="descname">_get_extracted_star_spectra_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_extracted_star_spectra_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the extracted star spectra</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_spectrum_frame_header">
<tt class="descname">_get_spectrum_frame_header</tt><big>(</big><em>frame_index</em>, <em>axis</em>, <em>apodization_function</em>, <em>phase=False</em>, <em>wavenumber=False</em><big>)</big><a class="headerlink" href="#process.Interferogram._get_spectrum_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the spectral frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame_index</strong> &#8211; Index of the frame.</li>
<li><strong>axis</strong> &#8211; Spectrum axis (must be in wavelength or in
wavenumber).</li>
<li><strong>phase</strong> &#8211; (Optional) If True the path is changed for a
phase cube (default False).</li>
<li><strong>wavenumber</strong> &#8211; (Optional) If True the axis is considered
to be in wavenumber. If False the axis is considered to be
in wavelength (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_spectrum_frame_path">
<tt class="descname">_get_spectrum_frame_path</tt><big>(</big><em>frame_index</em>, <em>stars_cube=False</em>, <em>phase=False</em><big>)</big><a class="headerlink" href="#process.Interferogram._get_spectrum_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to a spectrum frame given its
index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame_index</strong> &#8211; Index of the frame</li>
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</li>
<li><strong>phase</strong> &#8211; (Optional) If True the path is changed for a
phase cube (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_spectrum_header">
<tt class="descname">_get_spectrum_header</tt><big>(</big><em>axis</em>, <em>apodization_function</em>, <em>stars_cube=False</em>, <em>phase=False</em>, <em>wavenumber=False</em><big>)</big><a class="headerlink" href="#process.Interferogram._get_spectrum_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the spectal cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; Spectrum axis (must be in wavelength or in
wavenumber).</li>
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</li>
<li><strong>phase</strong> &#8211; (Optional) If True the path is changed for a
phase cube (default False).</li>
<li><strong>wavenumber</strong> &#8211; (Optional) If True the axis is considered
to be in wavenumber. If False the axis is considered to be
in wavelength (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_spectrum_list_path">
<tt class="descname">_get_spectrum_list_path</tt><big>(</big><em>stars_cube=False</em>, <em>phase=False</em><big>)</big><a class="headerlink" href="#process.Interferogram._get_spectrum_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the spectrum list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</li>
<li><strong>phase</strong> &#8211; (Optional) If True the path is changed for a
phase cube (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_spectrum_path">
<tt class="descname">_get_spectrum_path</tt><big>(</big><em>stars_cube=False</em>, <em>phase=False</em><big>)</big><a class="headerlink" href="#process.Interferogram._get_spectrum_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the spectral cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</li>
<li><strong>phase</strong> &#8211; (Optional) If True the path is changed for a
phase cube (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_stray_light_vector_header">
<tt class="descname">_get_stray_light_vector_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_stray_light_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the stray light vector</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_stray_light_vector_path">
<tt class="descname">_get_stray_light_vector_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_stray_light_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the stray light vector</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_transmission_vector_header">
<tt class="descname">_get_transmission_vector_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_transmission_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the transmission vector</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram._get_transmission_vector_path">
<tt class="descname">_get_transmission_vector_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Interferogram._get_transmission_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the transmission vector</p>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram.compute_phase_coeffs_vector">
<tt class="descname">compute_phase_coeffs_vector</tt><big>(</big><em>phase_map_paths</em>, <em>residual_map_path=None</em><big>)</big><a class="headerlink" href="#process.Interferogram.compute_phase_coeffs_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector containing the mean of the phase
coefficients for each given phase map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>phase_maps</strong> &#8211; Tuple of phase map paths. Coefficients are
sorted in the same order as the phase maps.</li>
<li><strong>residual_map</strong> &#8211; (Optional) If given this map is used to
get only the well fitted coefficients in order to compute a
more precise mean coefficent.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram.compute_spectrum">
<tt class="descname">compute_spectrum</tt><big>(</big><em>calibration_laser_map_path</em>, <em>bin</em>, <em>step</em>, <em>order</em>, <em>nm_laser</em>, <em>zpd_shift=None</em>, <em>polyfit_deg=1</em>, <em>n_phase=None</em>, <em>bad_frames_vector=None</em>, <em>window_type=None</em>, <em>stars_cube=False</em>, <em>phase_cube=False</em>, <em>phase_map_0_path=None</em>, <em>phase_coeffs=None</em>, <em>filter_file_path=None</em>, <em>balanced=True</em>, <em>smoothing_deg=2</em>, <em>fringes=None</em>, <em>wavenumber=False</em><big>)</big><a class="headerlink" href="#process.Interferogram.compute_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the spectrum from the corrected interferogram
frames. Can be used to compute spectrum for camera 1, camera 2
or merged interferogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calibration_laser_map_path</strong> &#8211; Path to the calibration
map. If set to None, the spectrum cube will not be
calibrated in wavelength.</li>
<li><strong>bin</strong> &#8211; The binning of the interferogram frames (equal to
the binning of the camera 1)</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>step</strong> &#8211; Step size in nm</li>
<li><strong>zpd_shift</strong> &#8211; (Optional) Shift of the ZPD in
frames. Automaticaly computed if none given.</li>
<li><strong>window_type</strong> &#8211; (Optional) Apodization window to be used
(Default None, no apodization)</li>
<li><strong>n_phase</strong> &#8211; (Optional) Number of points around ZPD to use
for phase correction. If 0, no phase correction will be done
and the resulting spectrum will be the absolute value of the
complex spectrum. If None, the number of points is set to 50
percent of the interferogram length (default None).</li>
<li><strong>polyfit_deg</strong> &#8211; (Optional) Degree of the polynomial fit to
the computed phase. If &lt; 0, no fit will be performed
(Default 1).</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Mask-like vector
containing ones for bad frames. Bad frames are replaced by
zeros using a special function that smoothes transition
between good parts and zeros (default None).</li>
<li><strong>stars_cube</strong> &#8211; (Optional) If True the process is optimized
for an interferogram cube containing only the interferogram
of some stars (This type of cube is mostly filled with
zeros). The resulting spectrum cube will be saved with a
different name (default False).</li>
<li><strong>phase_cube</strong> &#8211; (Optional) If True, only the phase cube is
returned. The number of points of the phase can be defined
with the option n_phase. The option polyfit_deg is
automatically set to -1 and the phase is returned without
being fitted (default False).</li>
<li><strong>phase_map_0_path</strong> &#8211; (Optional) This map contains the 0th
order coefficient of the phase. It must have the same
dimensions as the frames of the interferogram cube (default
None).</li>
<li><strong>phase_coeffs</strong> &#8211; (Optional) Phase coefficiens other than
the 0th order coefficient which is given by the phase
map_0. The phase coefficients are defined for a fixed number
of phase points and a given zpd shift. To avoid errors use
the same number of phase points for the spectrum computation
and for the phase computation. Try also to keep track of the
shift use to compute the phase cube (default None).</li>
<li><strong>filter_file_path</strong> &#8211; (Optional) Path to the filter
file. If given the filter edges are used to give a weight to
the phase points. See
<tt class="xref py py-meth docutils literal"><span class="pre">process.Spectrum.correct_filter()</span></tt> for more information
about the filter file.</li>
<li><strong>balanced</strong> &#8211; (Optional) If False, the interferogram is
considered as unbalanced. It is flipped before its
transformation to get a positive spectrum. Note that a
merged interferogram is balanced (default True).</li>
<li><strong>smoothing_deg</strong> &#8211; (Optional) Degree of zeros smoothing. A
higher degree means a smoother transition from zeros parts
(bad frames) to non-zero parts (good frames) of the
interferogram. Good parts on the other side of the ZPD in
symmetry with zeros parts are multiplied by 2. The same
transition is used to multiply interferogram points by zero
and 2 (default 2).</li>
<li><strong>fringes</strong> &#8211; (Optional) If not None, must be an array
giving for each fringe to remove its frequency and
intensity. The array must be like [[freq1, amp1], [freq2,
amp2], [freq3, amp3], ...]. Fringes are removed by dividing
the interferograms by a sinusoidal function representing a
periodically variable modulation efficiency (default None).</li>
<li><strong>wavenumber</strong> &#8211; (Optional) If True, the returned spectrum
is projected onto its original wavenumber axis (emission
lines and especially unapodized sinc emission lines are thus
symetric which is not the case if the spectrum is projected
onto a, more convenient, regular wavelength axis) (default
False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>External phase computation:</p>
<p class="last">In order to achieve a better phase correction it can be
useful to compute some of the phase coefficients from an
external source. Two parameters must be used <strong>together</strong> :
<cite>phase_map_path</cite> and <cite>phase_coeffs</cite> which can be computed
using <a class="reference internal" href="#process.Phase" title="process.Phase"><tt class="xref py py-class docutils literal"><span class="pre">process.Phase</span></tt></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Spectrum computation walks through 8 steps:</p>
<ol class="last arabic simple">
<li>Mean interferogram subtraction to suppress the
zero-frequency term in the spectrum</li>
<li>Low order polynomial subtraction to suppress low
frequency noise in the spectrum</li>
<li>Apodization (the user can choose which apodization
function to use)</li>
<li>Zero-padding to have two times more points in the
interferogram in order to keep the same resolution during
the Fourier transform.</li>
<li>ZPD shift to correct for a non-centered ZPD.</li>
<li>Fast Fourier Transform of the interferogram</li>
<li>Phase correction (if the user chooses to get the real
part of the spectrum with phase correction instead of the
power spectrum)</li>
<li>Wavelength correction using the data obtained with the
calibration cube.</li>
</ol>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.transform_interferogram()</span></tt></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#process.Phase" title="process.Phase"><tt class="xref py py-class docutils literal"><span class="pre">process.Phase</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram.correct_interferogram">
<tt class="descname">correct_interferogram</tt><big>(</big><em>transmission_vector_path</em>, <em>stray_light_vector_path</em><big>)</big><a class="headerlink" href="#process.Interferogram.correct_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct an interferogram cube for for variations
of sky transission and stray light.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sky_transmission_vector_path</strong> &#8211; Path to the transmission
vector.All the interferograms of the cube are divided by
this vector. The vector must have the same size as the 3rd
axis of the cube (the OPD axis).</li>
<li><strong>stray_light_vector_path</strong> &#8211; Path to the stray light
vector. This vector is substracted from the interferograms
of all the cube. The vector must have the same size as the
3rd axis of the cube (the OPD axis).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sky transmission vector gives the absorption
caused by clouds or airmass variation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The stray light vector gives the counts added
homogeneously to each frame caused by a cloud reflecting
light coming from the ground, the moon or the sun.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#process.Interferogram.create_correction_vectors" title="process.Interferogram.create_correction_vectors"><tt class="xref py py-meth docutils literal"><span class="pre">process.Interferogram.create_correction_vectors()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram.create_correction_vectors">
<tt class="descname">create_correction_vectors</tt><big>(</big><em>star_list_path</em>, <em>fwhm_arc</em>, <em>fov</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em>, <em>step_number=None</em>, <em>bad_frames_vector=[]</em>, <em>aperture_photometry=True</em><big>)</big><a class="headerlink" href="#process.Interferogram.create_correction_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sky transmission vector computed from star
photometry and an stray light vector computed from the median
of the frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> &#8211; Path to a list of star positions.</li>
<li><strong>box_size</strong> &#8211; (Optional) The size of the box in pixel
around each given star used to fit a 2D gaussian (default
15 pixels). Choose it to be between 3 and 6 times the
FWHM.</li>
<li><strong>step_number</strong> &#8211; (Optional) &#8216;Full&#8217; number of steps if the
cube was complete. Might be different from the &#8216;real&#8217; number
of steps obtained. Helps in finding ZPD (default None).</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Contains the index of the
frames considered as bad (default []).</li>
<li><strong>aperture_photometry</strong> &#8211; If True, flux of stars is computed
by aperture photometry. Else, The flux is evaluated given
the fit parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sky transmission vector gives the absorption
caused by clouds or airmass variation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The stray light vector gives the counts added
homogeneously to each frame caused by a cloud reflecting
light coming from the ground, the moon or the sun.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is intented to be used to correct a
&#8216;single camera&#8217; interferogram cube. In the case of a merged
interferogram this is already done by the
<a class="reference internal" href="#process.InterferogramMerger.merge" title="process.InterferogramMerger.merge"><tt class="xref py py-meth docutils literal"><span class="pre">process.InterferogramMerger.merge()</span></tt></a> with a far
better precision (because both cubes are used to compute it)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.Interferogram.extract_stars_spectrum">
<tt class="descname">extract_stars_spectrum</tt><big>(</big><em>star_list_path</em>, <em>fwhm_arc</em>, <em>fov</em>, <em>transmission_vector_path</em>, <em>stray_light_vector_path</em>, <em>calibration_laser_map_path</em>, <em>step</em>, <em>order</em>, <em>nm_laser</em>, <em>filter_file_path</em>, <em>step_nb</em>, <em>window_type=None</em>, <em>bad_frames_vector=None</em>, <em>smoothing_deg=2</em>, <em>aperture=True</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em>, <em>filter_correct=True</em>, <em>flat_spectrum_path=None</em>, <em>aper_coeff=3.0</em>, <em>saturation=None</em><big>)</big><a class="headerlink" href="#process.Interferogram.extract_stars_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the spectrum of the stars in a list of stars location
list by photometry.</p>
<p>This method may be used after
<a class="reference internal" href="#process.Interferogram.correct_interferogram" title="process.Interferogram.correct_interferogram"><tt class="xref py py-meth docutils literal"><span class="pre">process.Interferogram.correct_interferogram()</span></tt></a> has
created the nescessary data: transmission vector and added
light vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> &#8211; Path to a list of star positions. A
list of star positions can also be given as a list of tuples
[(x0, y0), (x1, y1), ...].</li>
<li><strong>fwhm_arc</strong> &#8211; rough FWHM of the stars in arcsec</li>
<li><strong>fov</strong> &#8211; Field of view of the frame in arcminutes (given
along x axis.</li>
<li><strong>transmission_vector_path</strong> &#8211; Variation of the sky
transmission. Must have the same size as the interferograms
of the cube.</li>
<li><strong>stray_light_vector_path</strong> &#8211; stray light vector. Must have
the same size as the interferograms of the cube.</li>
<li><strong>calibration_laser_map_path</strong> &#8211; Path to the calibration
laser map.</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>step</strong> &#8211; Step size in nm</li>
<li><strong>filter_file_path</strong> &#8211; Path to the filter file. If given the
filter edges can be used to give a weight to the phase
points. See <tt class="xref py py-meth docutils literal"><span class="pre">process.Spectrum.correct_filter()</span></tt> for more
information about the filter file.</li>
<li><strong>step_nb</strong> &#8211; Full number of steps in the interferogram. Can
be greater than the real number of steps if the cube has
been stopped before the end. Missing steps will be replaced
by zeros.</li>
<li><strong>window_type</strong> &#8211; (Optional) Apodization window to be used
(Default None, no apodization)</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Mask-like vector
containing ones for bad frames. Bad frames are replaced by
zeros using a special function that smoothes transition
between good parts and zeros (default None).</li>
<li><strong>aperture</strong> &#8211; (Optional) If True, flux of stars is computed
by aperture photometry. Else, The flux is evaluated given
the fit parameters (default True).</li>
<li><strong>profile_name</strong> &#8211; (Optional) PSF profile to use to fit
stars. Can be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default
&#8216;gaussian&#8217;). See:
<tt class="xref py py-meth docutils literal"><span class="pre">orb.astrometry.Astrometry.fit_stars_in_frame()</span></tt>.</li>
<li><strong>moffat_beta</strong> &#8211; (Optional) Beta parameter to use for
moffat PSF (default 3.5).</li>
<li><strong>filter_correct</strong> &#8211; (Optional) If True returned spectra
are corrected for filter. Points out of the filter band
are set to NaN (default True).</li>
<li><strong>flat_spectrum_path</strong> &#8211; (Optional) Path to a list of flat
spectrum frames. This is used to further correct the
resulting stars spectrum for fringing effects (default None).</li>
<li><strong>aper_coeff</strong> &#8211; (Optional) Aperture coefficient. The
aperture radius is Rap = aper_coeff * FWHM. Better when
between 1.5 to reduce the variation of the collected photons
with varying FWHM and 3. to account for the flux in the
wings (default 3., better for star with a high SNR).</li>
<li><strong>saturation</strong> &#8211; (Optional) If not None, all pixels above
the saturation level are removed from the fit (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interferogrammerger-class">
<h2><a class="toc-backref" href="#id4">InterferogramMerger class</a><a class="headerlink" href="#interferogrammerger-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.InterferogramMerger">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">InterferogramMerger</tt><big>(</big><em>image_list_path_A=None</em>, <em>image_list_path_B=None</em>, <em>bin_A=None</em>, <em>bin_B=None</em>, <em>pix_size_A=None</em>, <em>pix_size_B=None</em>, <em>data_prefix='temp_data_'</em>, <em>alignment_coeffs=None</em>, <em>project_header=[]</em>, <em>config_file_name='config.orb'</em>, <em>cube_A_project_header=[]</em>, <em>cube_B_project_header=[]</em>, <em>wcs_header=[]</em>, <em>overwrite=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Tools</span></tt></p>
<p>ORBS interferogram merging class.</p>
<p>The InterferogramMerger class is aimed to merge the interferogram
cubes of the two cameras of SpIOMM/SITELLE.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this class the letter &#8216;A&#8217; refers to the camera 1 and the
letter &#8216;B&#8217; to the camera 2</p>
</div>
<dl class="method">
<dt id="process.InterferogramMerger.__init__">
<tt class="descname">__init__</tt><big>(</big><em>image_list_path_A=None</em>, <em>image_list_path_B=None</em>, <em>bin_A=None</em>, <em>bin_B=None</em>, <em>pix_size_A=None</em>, <em>pix_size_B=None</em>, <em>data_prefix='temp_data_'</em>, <em>alignment_coeffs=None</em>, <em>project_header=[]</em>, <em>config_file_name='config.orb'</em>, <em>cube_A_project_header=[]</em>, <em>cube_B_project_header=[]</em>, <em>wcs_header=[]</em>, <em>overwrite=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize InterferogramMerger class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image_list_path_A</strong> &#8211; (Optional) Path to the image list of
the camera 1</li>
<li><strong>image_list_path_B</strong> &#8211; (Optional) Path to the image list of
the camera 2</li>
<li><strong>bin_A</strong> &#8211; (Optional) Binning factor of the camera A</li>
<li><strong>bin_B</strong> &#8211; (Optional) Binning factor of the camera B</li>
<li><strong>pix_size_A</strong> &#8211; (Optional) Pixel size of the camera A</li>
<li><strong>pix_size_A</strong> &#8211; (Optional) Pixel size of the camera B</li>
<li><strong>data_prefix</strong> &#8211; (Optional) Header and path of the files
created by the class</li>
<li><strong>config_file_name</strong> &#8211; (Optional) name of the config file to
use. Must be located in orbs/data/.</li>
<li><strong>project_header</strong> &#8211; (Optional) header section to be added
to each output files based on merged data (an empty list by
default).</li>
<li><strong>cube_A_project_header</strong> &#8211; (Optional) header section to be
added to each output files based on pure cube A data (an
empty list by default).</li>
<li><strong>cube_B_project_header</strong> &#8211; (Optional) header section to be
added to each output files based on pure cube B data (an
empty list by default).</li>
<li><strong>wcs_header</strong> &#8211; (Optional) header section describing WCS
that can be added to each created image files (an empty list
by default).</li>
<li><strong>alignment_coeffs</strong> &#8211; (Optional) Pre-calculated alignement
coefficients. Setting alignment_coeffs to something else
than &#8216;None&#8217; will avoid alignment coeffs calculation in
<a class="reference internal" href="#process.InterferogramMerger.find_alignment" title="process.InterferogramMerger.find_alignment"><tt class="xref py py-meth docutils literal"><span class="pre">process.InterferogramMerger.find_alignment()</span></tt></a></li>
<li><strong>overwrite</strong> &#8211; (Optional) If True existing FITS files will
be overwritten (default False).</li>
<li><strong>tuning_parameters</strong> &#8211; (Optional) Some parameters of the
methods can be tuned externally using this dictionary. The
dictionary must contains the full parameter name
(class.method.parameter_name) and its value. For example :
{&#8216;InterferogramMerger.find_alignment.BOX_SIZE&#8217;: 7}. Note
that only some parameters can be tuned. This possibility is
implemented into the method itself with the method
<tt class="xref py py-meth docutils literal"><span class="pre">orb.core.Tools._get_tuning_parameter()</span></tt>.</li>
<li><strong>indexer</strong> &#8211; (Optional) Must be a <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Indexer</span></tt>
instance. If not None created files can be indexed by this
instance.</li>
<li><strong>logfile_name</strong> &#8211; (Optional) Give a specific name to the
logfile (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_bad_frames_vector_header">
<tt class="descname">_get_bad_frames_vector_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_bad_frames_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the bad frames vector.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_bad_frames_vector_path">
<tt class="descname">_get_bad_frames_vector_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_bad_frames_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the bad frames vector.</p>
<p>This vector is created by
<a class="reference internal" href="#process.InterferogramMerger.merge" title="process.InterferogramMerger.merge"><tt class="xref py py-meth docutils literal"><span class="pre">process.InterferogramMerger.merge()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_calibration_stars_header">
<tt class="descname">_get_calibration_stars_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_calibration_stars_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the calibration stars data file.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_calibration_stars_path">
<tt class="descname">_get_calibration_stars_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_calibration_stars_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to a data file containing the merged
interferograms of the calibrated stars</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_deep_frame_header">
<tt class="descname">_get_deep_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_deep_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the deep frame.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_deep_frame_path">
<tt class="descname">_get_deep_frame_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_deep_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the deep frame.</p>
<p>The energy map is the mean frame from the merged cube. It is
useful to check the alignement.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_energy_map_header">
<tt class="descname">_get_energy_map_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_energy_map_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the energy map.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_energy_map_path">
<tt class="descname">_get_energy_map_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_energy_map_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the energy map.</p>
<p>The energy map is the mean frame from the merged cube. It is
useful to check the alignement.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_ext_illumination_vector_header">
<tt class="descname">_get_ext_illumination_vector_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_ext_illumination_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the external illumination vector.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_ext_illumination_vector_path">
<tt class="descname">_get_ext_illumination_vector_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_ext_illumination_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the external illumination vector.</p>
<p>The external illuminaton vector records the external
illumination difference between both cameras (e.g. if one
camera get some diffused light from the sky while the other is
well isolated). This vector is used to correct
interferograms.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_extracted_star_spectra_header">
<tt class="descname">_get_extracted_star_spectra_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_extracted_star_spectra_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of a data file containing the spectra of
the extracted stars</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_extracted_star_spectra_path">
<tt class="descname">_get_extracted_star_spectra_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_extracted_star_spectra_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to a data file containing the spectra of
the extracted stars</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_guess_matrix_header">
<tt class="descname">_get_guess_matrix_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_guess_matrix_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return path to the guess matrix</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_guess_matrix_path">
<tt class="descname">_get_guess_matrix_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_guess_matrix_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return path to the guess matrix</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_merged_interfero_frame_header">
<tt class="descname">_get_merged_interfero_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_merged_interfero_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the merged interferogram frames.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_merged_interfero_frame_list_path">
<tt class="descname">_get_merged_interfero_frame_list_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_merged_interfero_frame_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the list of frames of the merged cube</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_merged_interfero_frame_path">
<tt class="descname">_get_merged_interfero_frame_path</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_merged_interfero_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the merged interferogram frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> &#8211; Index of the merged interferogram frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_modulation_ratio_header">
<tt class="descname">_get_modulation_ratio_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_modulation_ratio_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the modulation ratio.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_modulation_ratio_path">
<tt class="descname">_get_modulation_ratio_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_modulation_ratio_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the modulation ratio.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_stars_interfero_frame_header">
<tt class="descname">_get_stars_interfero_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_stars_interfero_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the merged interferogram frames
containing only the photometrical data for the stars.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_stars_interfero_frame_list_path">
<tt class="descname">_get_stars_interfero_frame_list_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_stars_interfero_frame_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the list of frames of the stars cube</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_stars_interfero_frame_path">
<tt class="descname">_get_stars_interfero_frame_path</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_stars_interfero_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the stars interferogram frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> &#8211; Index of the merged interferogram frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_stray_light_vector_header">
<tt class="descname">_get_stray_light_vector_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_stray_light_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the stray light vector.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_stray_light_vector_path">
<tt class="descname">_get_stray_light_vector_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_stray_light_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the stray light vector.</p>
<p>The external illuminaton vector records lights coming from
reflections over clouds, the moon or the sun.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_transformed_interfero_frame_header">
<tt class="descname">_get_transformed_interfero_frame_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_transformed_interfero_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the transformed interferogram frames.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_transformed_interfero_frame_list_path">
<tt class="descname">_get_transformed_interfero_frame_list_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_transformed_interfero_frame_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the list of frames of the transformed cube</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_transformed_interfero_frame_path">
<tt class="descname">_get_transformed_interfero_frame_path</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_transformed_interfero_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the transformed interferogram frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> &#8211; Index of the transformed interferogram frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_transmission_vector_header">
<tt class="descname">_get_transmission_vector_header</tt><big>(</big><em>err=False</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_transmission_vector_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the transmission vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>err</strong> &#8211; (Optional) True if error vector (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger._get_transmission_vector_path">
<tt class="descname">_get_transmission_vector_path</tt><big>(</big><em>err=False</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger._get_transmission_vector_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to the transmission vector.</p>
<p>Transmission vector is the vector used to correct
interferograms for the variations of the sky transmission.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>err</strong> &#8211; (Optional) True if error vector (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.add_missing_frames">
<tt class="descname">add_missing_frames</tt><big>(</big><em>step_number</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.add_missing_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Add non taken frames at the end of a cube in order to
complete it and have a centered ZDP. Useful when a cube could
not be completed during the night.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step_number</strong> &#8211; Number of steps for a full cube.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.alternative_merge">
<tt class="descname">alternative_merge</tt><big>(</big><em>add_frameB=True</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.alternative_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative merging process.</p>
<p>Star photometry is not used during the merging process. Might
be more noisy but useful if for some reason the correction
vectors cannot be well computed (e.g. not enough good stars,
intense emission lines everywhere in the field)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>add_frameB</strong> &#8211; (Optional) Set it to False if B frame is
too noisy to be added to the result. In this case frame B
is used only to correct for variations of flux from the
source (airmass, clouds ...) (Default False).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Cubes are merged using the formula (for the nth frame):</p>
<div class="last math">
\[Frame_{n,M} = \frac{Frame_{n,1} -
Frame_{n,2}}{Frame_{n,1} + Frame_{n,2}}\]</div>
</div>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.extract_stars_spectrum">
<tt class="descname">extract_stars_spectrum</tt><big>(</big><em>star_list_path</em>, <em>fwhm_arc</em>, <em>fov</em>, <em>modulation_ratio_path</em>, <em>transmission_vector_path</em>, <em>ext_illumination_vector_path</em>, <em>stray_light_vector_path</em>, <em>calibration_laser_map_path</em>, <em>step</em>, <em>order</em>, <em>nm_laser</em>, <em>filter_file_path</em>, <em>step_nb</em>, <em>window_type=None</em>, <em>bad_frames_vector=None</em>, <em>phase_map_0_path=None</em>, <em>phase_coeffs=None</em>, <em>smoothing_deg=2</em>, <em>aperture=True</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em>, <em>n_phase=None</em>, <em>auto_phase=False</em>, <em>filter_correct=True</em>, <em>flat_spectrum_path=None</em>, <em>aper_coeff=3.0</em>, <em>saturation=None</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.extract_stars_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the spectrum of the stars in a list of stars location
list by photometry.</p>
<p>This method may be used after
<a class="reference internal" href="#process.InterferogramMerger.merge" title="process.InterferogramMerger.merge"><tt class="xref py py-meth docutils literal"><span class="pre">process.InterferogramMerger.merge()</span></tt></a> has created the
nescessary data: modulation ratio, transmission vector and
external illumination vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> &#8211; Path to a list of star positions. A
list of star positions can also be given as a list of tuples
[(x0, y0), (x1, y1), ...].</li>
<li><strong>fwhm_arc</strong> &#8211; rough FWHM of the stars in arcsec</li>
<li><strong>fov</strong> &#8211; Field of view of the frame in arcminutes (given
along x axis.</li>
<li><strong>modulation_ratio_path</strong> &#8211; Modulation ratio path.</li>
<li><strong>transmission_vector_path</strong> &#8211; Variation of the sky
transmission. Must have the same size as the interferograms
of the cube.</li>
<li><strong>ext_illumination_vector_path</strong> &#8211; Level of external
illumination.  This is a small correction for the difference
of incoming light between both cameras. Must have the same
size as the interferograms of the cube.</li>
<li><strong>stray_light_vector_path</strong> &#8211; Stray light vector. Must have
the same size as the interferograms of the cube.</li>
<li><strong>calibration_laser_map_path</strong> &#8211; Path to the calibration
laser map.</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>step</strong> &#8211; Step size in nm</li>
<li><strong>filter_file_path</strong> &#8211; Path to the filter file. If given the
filter edges can be used to give a weight to the phase
points. See <tt class="xref py py-meth docutils literal"><span class="pre">process.Spectrum.correct_filter()</span></tt> for more
information about the filter file.</li>
<li><strong>step_nb</strong> &#8211; Full number of steps in the interferogram. Can
be greater than the real number of steps if the cube has
been stopped before the end. Missing steps will be replaced
by zeros.</li>
<li><strong>window_type</strong> &#8211; (Optional) Apodization window to be used
(Default None, no apodization)</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Mask-like vector
containing ones for bad frames. Bad frames are replaced by
zeros using a special function that smoothes transition
between good parts and zeros (default None).</li>
<li><strong>phase_map_0_path</strong> &#8211; (Optional) This map contains the 0th
order coefficient of the phase. It must have the same
dimensions as the frames of the interferogram cube (default
None).</li>
<li><strong>phase_coeffs</strong> &#8211; (Optional) Phase coefficiens other than
the 0th order coefficient which is given by the phase
map_0. The phase coefficients are defined for a fixed number
of phase points and a given zpd shift. To avoid errors use
the same number of phase points for the spectrum computation
and for the phase computation. Try also to keep track of the
shift use to compute the phase cube (default None).</li>
<li><strong>aperture</strong> &#8211; (Optional) If True, flux of stars is computed
by aperture photometry. Else, The flux is evaluated given
the fit parameters (default True).</li>
<li><strong>profile_name</strong> &#8211; (Optional) PSF profile to use to fit
stars. Can be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default
&#8216;gaussian&#8217;). See:
<tt class="xref py py-meth docutils literal"><span class="pre">orb.astrometry.Astrometry.fit_stars_in_frame()</span></tt>.</li>
<li><strong>moffat_beta</strong> &#8211; (Optional) Beta parameter to use for
moffat PSF (default 3.5).</li>
<li><strong>n_phase</strong> &#8211; (Optional) Number of points around ZPD to use
for phase correction. If 0, no phase correction will be done
and the resulting spectrum will be the absolute value of the
complex spectrum. If None, the number of points is set to 50
percent of the interferogram length (default None).</li>
<li><strong>auto_phase</strong> &#8211; (Optional) If True, phase is computed for
each star independantly. Useful for high SNR stars when no
reliable external phase can be provided (e.g. Standard
stars). Note that if auto_phase is set to True, phase will
be corrected even if n_phase is set to 0. (default False).</li>
<li><strong>filter_correct</strong> &#8211; (Optional) If True returned spectra
are corrected for filter. Points out of the filter band
are set to NaN (default True).</li>
<li><strong>flat_spectrum_path</strong> &#8211; (Optional) Path to a list of flat
spectrum frames. This is used to further correct the
resulting stars spectrum for fringing effects (default None).</li>
<li><strong>aper_coeff</strong> &#8211; (Optional) Aperture coefficient. The
aperture radius is Rap = aper_coeff * FWHM. Better when
between 1.5 to reduce the variation of the collected photons
with varying FWHM and 3. to account for the flux in the
wings (default 3., better for star with a high SNR).</li>
<li><strong>saturation</strong> &#8211; (Optional) If not None, allpixels above the
saturation level are removed from the fit (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.find_alignment">
<tt class="descname">find_alignment</tt><big>(</big><em>star_list_path</em>, <em>init_angle</em>, <em>init_dx</em>, <em>init_dy</em>, <em>fwhm_arc_A</em>, <em>fov_A</em>, <em>full_precision=False</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.find_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alignment coefficients to align the cube of the
camera 2 on the cube of the camera 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> &#8211; Path to a list of stars</li>
<li><strong>init_angle</strong> &#8211; Initial rotation angle between images</li>
<li><strong>init_dx</strong> &#8211; Initial shift along x axis between images</li>
<li><strong>init_dy</strong> &#8211; Initial shift along y axis between images</li>
<li><strong>fwhm_arc_A</strong> &#8211; rough FWHM of the stars in arcsec in the
camera A.</li>
<li><strong>fov_A</strong> &#8211; Field of view of the camera A in arcminutes (given
along x axis.</li>
<li><strong>full_precision</strong> &#8211; (Optional) If True tip and tilt angles
(da and db) are checked. Note that this can take a lot of
time. If False da and db are set to 0 (default False).</li>
<li><strong>profile_name</strong> &#8211; (Optional) PSF profile to use to fit
stars. Can be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default
&#8216;gaussian&#8217;). See:
<tt class="xref py py-meth docutils literal"><span class="pre">orb.astrometry.Astrometry.fit_stars_in_frame()</span></tt>.</li>
<li><strong>moffat_beta</strong> &#8211; (Optional) Beta parameter to use for
moffat PSF (default 3.5).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The alignement coefficients are:</p>
<ul class="last simple">
<li>dx : shift along x axis in pixels</li>
<li>dy : shift along y axis in pixels</li>
<li>dr : rotation angle between images (the center of rotation
is the center of the images of the camera 1) in degrees</li>
<li>da : tip angle between cameras (along x axis) in degrees</li>
<li>db : tilt angle between cameras (along y axis) in degrees</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The process tries to find the stars detected in the camera A in the frame of the camera B. It goes through 2 steps:</p>
<ol class="last arabic simple">
<li>Rough alignment only looking over dx, dy. dr is kept to
its initial value (init_angle), da and db are set to 0.</li>
<li>First optimization pass only looking over dx, dy and
dr. da and db are set to 0.</li>
<li>Second optimization pass adding da and db to the
parameters. This pass can be removed if full_precision
is set to False.</li>
</ol>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This alignment process do not work if the initial
parameters are too far from the real value. The angle must
be known within a few degrees. The shift must be known
within 4 % of the frame size (The latter can be changed
using the SIZE_COEFF constant)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.merge">
<tt class="descname">merge</tt><big>(</big><em>star_list_path</em>, <em>step_number</em>, <em>fwhm_arc</em>, <em>fov</em>, <em>add_frameB=True</em>, <em>smooth_vector=True</em>, <em>create_stars_cube=False</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em>, <em>bad_frames_vector=[]</em>, <em>compute_ext_light=True</em>, <em>aperture_photometry=True</em>, <em>readout_noise_1=10.0</em>, <em>dark_current_level_1=0.0</em>, <em>readout_noise_2=10.0</em>, <em>dark_current_level_2=0.0</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the cube of the camera 1 and the transformed cube of the
camera 2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_path</strong> &#8211; Path to a list of star positions.</li>
<li><strong>step_number</strong> &#8211; Number of steps for a full cube.</li>
<li><strong>add_frameB</strong> &#8211; (Optional) Set it to False if B frame is
too noisy to be added to the result. In this case frame B
is used only to correct for variations of flux from the
source (airmass, clouds ...) (Default False).</li>
<li><strong>smooth_vector</strong> &#8211; (Optional) If True smooth the obtained
correction vector with a gaussian weighted moving average.
Reduce the possible high frequency noise of the correction
function. (Default True).</li>
<li><strong>fwhm_arc</strong> &#8211; rough FWHM of the stars in arcsec</li>
<li><strong>fov</strong> &#8211; Field of view of the frame in arcminutes (given
along x axis.</li>
<li><strong>create_stars_cube</strong> &#8211; (Optional) If True only the
interferogram of the stars in the star list are computed
using their photometric parameters returned by a 2D gaussian
fit (default False).</li>
<li><strong>profile_name</strong> &#8211; (Optional) PSF profile to use to fit
stars. Can be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default
&#8216;gaussian&#8217;). See:
<tt class="xref py py-meth docutils literal"><span class="pre">orb.astrometry.Astrometry.fit_stars_in_frame()</span></tt>.</li>
<li><strong>moffat_beta</strong> &#8211; (Optional) Beta parameter to use for
moffat PSF (default 3.5).</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Contains the index of the
frames considered as bad(default []).</li>
<li><strong>compute_ext_light</strong> &#8211; (Optional) If True compute the
external light vector. Make sure that there&#8217;s enough &#8216;sky&#8217;
pixels in the frame. The vector will be deeply affected if
the object covers the whole area (default True).</li>
<li><strong>aperture_photometry</strong> &#8211; (Optional) If True, flux of stars
is computed by aperture photometry. Else, The flux is
evaluated given the fit parameters (default True).</li>
<li><strong>readout_noise_1</strong> &#8211; (Optional) Readout noise in ADU/pixel
of camera 1 (can be computed from bias frames:
std(master_bias_frame)) (default 10.)</li>
<li><strong>dark_current_level_1</strong> &#8211; (Optional) Dark current level of
camera 1 in ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</li>
<li><strong>readout_noise_2</strong> &#8211; (Optional) Readout noise in ADU/pixel
of camera 2 (can be computed from bias frames:
std(master_bias_frame)) (default 10.)</li>
<li><strong>dark_current_level_2</strong> &#8211; (Optional) Dark current level of
camera 2 in ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The merging process goes throught 3 steps:</p>
<ol class="last arabic">
<li><p class="first">Compute external illumination vector: This vector
records the external illumination difference between
both cameras (e.g. if one camera get some diffused light
from the sky while the other is well isolated). This
vector is used to correct interferograms.</p>
</li>
<li><p class="first">Compute transmission vector: the transmission vector is
computed from star photometry (2D gaussian or moffat
fitting. See
<tt class="xref py py-meth docutils literal"><span class="pre">orb.astrometry.Astrometry.fit_stars_in_cube()</span></tt>) of
both frames from camera 1 and camera 2 (frames must
therefore be aligned).</p>
</li>
<li><p class="first">Cube merging using for each frame (nth) of the cube the
formula:</p>
<div class="math">
\[Frame_{n,M} = \frac{Frame_{n,1}
-Frame_{n,2}}{transmission vector[n]}\]</div>
</li>
</ol>
</div>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.print_alignment_coeffs">
<tt class="descname">print_alignment_coeffs</tt><big>(</big><big>)</big><a class="headerlink" href="#process.InterferogramMerger.print_alignment_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the alignement coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="process.InterferogramMerger.transform">
<tt class="descname">transform</tt><big>(</big><em>interp_order=1</em><big>)</big><a class="headerlink" href="#process.InterferogramMerger.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform cube B given a set of alignment coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>interp_order</strong> &#8211; Order of interpolation. (1: linear by default)</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">orb.utils.transform_frame()</span></tt></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="calibrationlaser-class">
<h2><a class="toc-backref" href="#id5">CalibrationLaser class</a><a class="headerlink" href="#calibrationlaser-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.CalibrationLaser">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">CalibrationLaser</tt><big>(</big><em>image_list_path</em>, <em>image_mode='classic'</em>, <em>chip_index=1</em>, <em>binning=1</em>, <em>data_prefix='temp_data_'</em>, <em>config_file_name='config.orb'</em>, <em>project_header=[]</em>, <em>wcs_header=[]</em>, <em>calibration_laser_header=[]</em>, <em>overwrite=False</em>, <em>silent_init=False</em>, <em>no_log=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.CalibrationLaser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Cube</span></tt></p>
<p>ORBS calibration laser processing class.</p>
<p>CalibrationLaser class is aimed to compute the calibration laser map that
is used to correct for the <strong>off-axis effect</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <strong>off-axis effect</strong> comes from the angle between one
pixel of a camera and the optical axis of the interferometer. For
a given displacement of the mirror (step) the optical path
difference &#8216;seen&#8217; by a pixel is different and depends on the
off-axis angle. The effect on the spectrum corresponds to a
changing step in wavelength (between two channels) and thus an
expanded spectrum relatively to its theoretical shape.</p>
<p>The <strong>calibration laser cube</strong> is an interferogram cube taken with a
monochromatic light. The real position of the emission line (its
channel) help us to correct for the step variations using the
formula :</p>
<div class="last math">
\[step_{real} = step_{th} * \frac{\lambda_{LASER}}{channel}\]</div>
</div>
<dl class="method">
<dt id="process.CalibrationLaser._get_calibration_laser_map_header">
<tt class="descname">_get_calibration_laser_map_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.CalibrationLaser._get_calibration_laser_map_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the calibration laser map.</p>
</dd></dl>

<dl class="method">
<dt id="process.CalibrationLaser._get_calibration_laser_map_path">
<tt class="descname">_get_calibration_laser_map_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.CalibrationLaser._get_calibration_laser_map_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the calibration laser map.</p>
</dd></dl>

<dl class="method">
<dt id="process.CalibrationLaser._get_calibration_laser_spectrum_header">
<tt class="descname">_get_calibration_laser_spectrum_header</tt><big>(</big><em>nm_axis</em><big>)</big><a class="headerlink" href="#process.CalibrationLaser._get_calibration_laser_spectrum_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the calibration spectrum cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nm_axis</strong> &#8211; Wavelength axis in nanometers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.CalibrationLaser._get_calibration_laser_spectrum_path">
<tt class="descname">_get_calibration_laser_spectrum_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.CalibrationLaser._get_calibration_laser_spectrum_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the reduced calibration laser cube for
checking.</p>
</dd></dl>

<dl class="method">
<dt id="process.CalibrationLaser.create_calibration_laser_map">
<tt class="descname">create_calibration_laser_map</tt><big>(</big><em>order=30</em>, <em>step=9765</em>, <em>get_calibration_laser_spectrum=False</em>, <em>fast=True</em><big>)</big><a class="headerlink" href="#process.CalibrationLaser.create_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the calibration laser map.</p>
<p>Compute the spectral cube from the calibration laser cube and
create the calibration laser map containing the fitted central
position of the emission line for each pixel of the image
plane (x/y axes).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order</strong> &#8211; (Optional) Folding order</li>
<li><strong>step</strong> &#8211; (Optional) Step size in um</li>
<li><strong>get_calibration_laser_spectrum</strong> &#8211; (Optional) If True return the
calibration laser spectrum</li>
<li><strong>fast</strong> &#8211; (Optional) If False a sinc^2 is fitted so the fit
is better and the procedure becomes slower. If True a
gaussian is fitted (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="spectrum-class">
<h2><a class="toc-backref" href="#id6">Spectrum class</a><a class="headerlink" href="#spectrum-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.Spectrum">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">Spectrum</tt><big>(</big><em>image_list_path</em>, <em>image_mode='classic'</em>, <em>chip_index=1</em>, <em>binning=1</em>, <em>data_prefix='temp_data_'</em>, <em>config_file_name='config.orb'</em>, <em>project_header=[]</em>, <em>wcs_header=[]</em>, <em>calibration_laser_header=[]</em>, <em>overwrite=False</em>, <em>silent_init=False</em>, <em>no_log=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.Spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Cube</span></tt></p>
<p>ORBS spectrum processing class.</p>
<p>This class is used to correct the spectrum computed by the
Interferogram class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spectrum_cube_path</strong> &#8211; Path to the spectrum cube</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="process.Spectrum._get_calibrated_spectrum_frame_header">
<tt class="descname">_get_calibrated_spectrum_frame_header</tt><big>(</big><em>frame_index</em>, <em>axis</em>, <em>apodization_function</em>, <em>stars_cube=False</em>, <em>wavenumber=False</em><big>)</big><a class="headerlink" href="#process.Spectrum._get_calibrated_spectrum_frame_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the calibrated spectral frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame_index</strong> &#8211; Index of the frame.</li>
<li><strong>axis</strong> &#8211; Spectrum axis (must be in wavelength or in
wavenumber).</li>
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed contains
only the spectrum of some stars. The default path name is
changed (default False).</li>
<li><strong>wavenumber</strong> &#8211; (Optional) If True the axis is considered
to be in wavenumber. If False the axis is considered to be
in wavelength (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_calibrated_spectrum_frame_path">
<tt class="descname">_get_calibrated_spectrum_frame_path</tt><big>(</big><em>frame_index</em>, <em>stars_cube=False</em><big>)</big><a class="headerlink" href="#process.Spectrum._get_calibrated_spectrum_frame_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to a calibrated spectral frame given its
index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame_index</strong> &#8211; Index of the frame</li>
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_calibrated_spectrum_header">
<tt class="descname">_get_calibrated_spectrum_header</tt><big>(</big><em>axis</em>, <em>apodization_function</em>, <em>stars_cube=False</em>, <em>wavenumber=False</em><big>)</big><a class="headerlink" href="#process.Spectrum._get_calibrated_spectrum_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the calibrated spectral cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; Spectrum axis (must be in wavelength or in
wavenumber).</li>
<li><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</li>
<li><strong>wavenumber</strong> &#8211; (Optional) If True the axis is considered
to be in wavenumber. If False the axis is considered to be
in wavelength (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_calibrated_spectrum_list_path">
<tt class="descname">_get_calibrated_spectrum_list_path</tt><big>(</big><em>stars_cube=False</em><big>)</big><a class="headerlink" href="#process.Spectrum._get_calibrated_spectrum_list_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the calibrated spectrum list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_calibrated_spectrum_path">
<tt class="descname">_get_calibrated_spectrum_path</tt><big>(</big><em>stars_cube=False</em><big>)</big><a class="headerlink" href="#process.Spectrum._get_calibrated_spectrum_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the calibrated spectral cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stars_cube</strong> &#8211; (Optional) The spectrum computed
contains only the spectrum of some stars. The default path
name is changed (default False).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_modulation_efficiency_map_header">
<tt class="descname">_get_modulation_efficiency_map_header</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Spectrum._get_modulation_efficiency_map_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the modulation efficiency map.</p>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_modulation_efficiency_map_path">
<tt class="descname">_get_modulation_efficiency_map_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Spectrum._get_modulation_efficiency_map_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return path to the modulation efficiency map.</p>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._get_stars_coords_path">
<tt class="descname">_get_stars_coords_path</tt><big>(</big><big>)</big><a class="headerlink" href="#process.Spectrum._get_stars_coords_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return path to the list of stars coordinates used to correct WCS</p>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum._update_hdr_wcs">
<tt class="descname">_update_hdr_wcs</tt><big>(</big><em>hdr</em>, <em>wcs_hdr</em><big>)</big><a class="headerlink" href="#process.Spectrum._update_hdr_wcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a header with WCS parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdr</strong> &#8211; A pyfits.Header() instance</li>
<li><strong>wcs_header</strong> &#8211; A pyfits.Header() instance containing the
new WCS parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum.calibrate">
<tt class="descname">calibrate</tt><big>(</big><em>filter_file_path</em>, <em>step</em>, <em>order</em>, <em>stars_cube=False</em>, <em>correct_wcs=None</em>, <em>flux_calibration_vector=None</em>, <em>deep_frame_path=None</em>, <em>mean_flux=True</em>, <em>wavenumber=False</em>, <em>calibration_laser_map_path=None</em>, <em>nm_laser=None</em>, <em>standard_header=None</em><big>)</big><a class="headerlink" href="#process.Spectrum.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calibrate spectrum cube: correct for filter transmission
function, correct WCS parameters and flux calibration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filter_file_path</strong> &#8211; The path to the file containing the
filter transmission function.</li>
<li><strong>step</strong> &#8211; Step size of the interferogram in nm.</li>
<li><strong>order</strong> &#8211; Folding order of the interferogram.</li>
<li><strong>stars_cube</strong> &#8211; (Optional) True if the spectral cube is a
star cube (default False).</li>
<li><strong>correct_wcs</strong> &#8211; (Optional) Must be a pywcs.WCS
instance. If not None header of the corrected spectrum
cube is updated with the new WCS.</li>
<li><strong>flux_calibration_vector</strong> &#8211; (Optional) Must be a vector
calibrated in erg/cm^2/s/A as the one given by
<a class="reference internal" href="#process.Spectrum.get_flux_calibration_vector" title="process.Spectrum.get_flux_calibration_vector"><tt class="xref py py-meth docutils literal"><span class="pre">process.Spectrum.get_flux_calibration_vector()</span></tt></a>. Each
spectrum will be multiplied by this vector to be flux
calibrated.</li>
<li><strong>deep_frame_path</strong> &#8211; (Optional) Path to the deep frame of
the interferogram cube. Useful to get the mean modulation
efficiency and rescale flux.</li>
<li><strong>mean_flux</strong> &#8211; (Optional) If True, the flux calibration
vector gives only a mean flux for all the wavelength and
does not correct for the filter. In this case the filter
correction is done but the filter function is normalized
beacuse the flux calibration already takes into account the
mean flux loss due to the filter. If False, the flux
calibration vector is considered to correct for everything
included the filter and no filter correction is done
(default True).</li>
<li><strong>wavenumber</strong> &#8211; (Optional) If True, the spectrum is
considered to be in wavenumber. If False it is considered to
be in wavelength (default False).</li>
<li><strong>calibration_laser_map_path</strong> &#8211; (Optional) If not None the
input spectrum is considered as uncalibrated for
wavelength. The filter correction is thus applied taking
into account the calibration laser map (default None).</li>
<li><strong>nm_laser</strong> &#8211; (Optional) Must be set if a calibration laser
map is given. This option has no use in the other case and
can be set to None.</li>
<li><strong>standard_header</strong> &#8211; (Optional) Header for the standard
star used for flux calibration. This header part will be
appended to the FITS header.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The filter file used must have two colums separated
by a space character. The first column contains the
wavelength axis in nm. The second column contains the
transmission coefficients. Comments are preceded with a #.
Filter edges can be specified using the keywords :
FILTER_MIN and FILTER_MAX:</p>
<div class="last highlight-python"><div class="highlight"><pre>## ORBS filter file 
# Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;
# Filter name : SpIOMM_R
# Wavelength in nm | Transmission percentage
# FILTER_MIN 648
# FILTER_MAX 678
1000 0.001201585284
999.7999878 0.009733387269
999.5999756 -0.0004460749624
999.4000244 0.01378122438
999.2000122 0.002538740868
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="process.Spectrum.get_flux_calibration_vector">
<tt class="descname">get_flux_calibration_vector</tt><big>(</big><em>std_spectrum_path</em>, <em>std_name</em>, <em>step</em>, <em>order</em>, <em>exp_time</em>, <em>filter_file_path</em>, <em>mean_vector=True</em><big>)</big><a class="headerlink" href="#process.Spectrum.get_flux_calibration_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a flux calibration vector in [erg/cm^2/s/A]/ADU on the range
corresponding to the observation parameters of the spectrum to
be calibrated.</p>
<p>The spectrum to be calibrated can then be simply multiplied by
the returned vector to be converted in [erg/cm^2/s/A]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>std_spectrum_path</strong> &#8211; Path to the standard spectrum</li>
<li><strong>std_name</strong> &#8211; Name of the standard</li>
<li><strong>step</strong> &#8211; Step size of the spectrum to calibrate</li>
<li><strong>order</strong> &#8211; Order of the spectrum to calibrate</li>
<li><strong>exp_time</strong> &#8211; Exposition time of the spectrum to calibrate</li>
<li><strong>filter_file_path</strong> &#8211; Path to the filter file. If given the
filter edges can be used to give a weight to the phase
points. See <tt class="xref py py-meth docutils literal"><span class="pre">process.Spectrum.correct_filter()</span></tt> for more
information about the filter file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Paran mean_vector:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">(Optional) If True, returned vector is a
&#8216;flat&#8217; vector of the same value corresponding to the mean of
the obtained calibration vector. Useful for bad quality
standard data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="phase-class">
<h2><a class="toc-backref" href="#id7">Phase class</a><a class="headerlink" href="#phase-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.Phase">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">Phase</tt><big>(</big><em>image_list_path</em>, <em>image_mode='classic'</em>, <em>chip_index=1</em>, <em>binning=1</em>, <em>data_prefix='temp_data_'</em>, <em>config_file_name='config.orb'</em>, <em>project_header=[]</em>, <em>wcs_header=[]</em>, <em>calibration_laser_header=[]</em>, <em>overwrite=False</em>, <em>silent_init=False</em>, <em>no_log=False</em>, <em>tuning_parameters={}</em>, <em>indexer=None</em>, <em>logfile_name=None</em><big>)</big><a class="headerlink" href="#process.Phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Cube</span></tt></p>
<p>ORBS phase processing class.</p>
<p>Used to create the phase maps used to correct phase in spectra.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Phase data can be obtained by transforming interferogram
cubes into a phase cube using <a class="reference internal" href="#process.Interferogram" title="process.Interferogram"><tt class="xref py py-class docutils literal"><span class="pre">process.Interferogram</span></tt></a>.</p>
</div>
<dl class="method">
<dt id="process.Phase._get_phase_map_header">
<tt class="descname">_get_phase_map_header</tt><big>(</big><em>order</em>, <em>phase_map_type=None</em><big>)</big><a class="headerlink" href="#process.Phase._get_phase_map_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the header of the phase map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order</strong> &#8211; Order of the parameter of the polynomial fitted
to the phase.</li>
<li><strong>phase_map_type</strong> &#8211; (Optional) Type of phase map. Must be
None, &#8216;smoothed&#8217;, &#8216;fitted&#8217;, &#8216;error&#8217; or &#8216;residual&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">smoothed, fitted and error are incompatible. If more
than one of those options are set to True the priority order
is smoothed, then fitted, then error.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.Phase._get_phase_map_path">
<tt class="descname">_get_phase_map_path</tt><big>(</big><em>order</em>, <em>phase_map_type=None</em><big>)</big><a class="headerlink" href="#process.Phase._get_phase_map_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default path to the phase map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order</strong> &#8211; Order of the parameter of the polynomial fitted
to the phase.</li>
<li><strong>phase_map_type</strong> &#8211; (Optional) Type of phase map. Must be
None, &#8216;smoothed&#8217;, &#8216;fitted&#8217;, &#8216;error&#8217; or &#8216;residual&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Phase.create_phase_maps">
<tt class="descname">create_phase_maps</tt><big>(</big><em>calibration_laser_map_path</em>, <em>filter_file_path</em>, <em>nm_laser</em>, <em>step</em>, <em>order</em>, <em>interferogram_length=None</em>, <em>fit_order=2</em>, <em>flat_cube=False</em><big>)</big><a class="headerlink" href="#process.Phase.create_phase_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Create phase maps. One phase map is created for each order
of the polynomial fit (e.g. 3 maps are created when fit_order
= 2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calibration_laser_map_path</strong> &#8211; Path to the
calibration laser map.</li>
<li><strong>filter_file_path</strong> &#8211; Path to the filter file. see
<tt class="xref py py-meth docutils literal"><span class="pre">process.Spectrum.correct_filter()</span></tt> for more information
about the filter file.</li>
<li><strong>nm_laser</strong> &#8211; Wavelength [in nm] of the laser used to
create the calibration laser map.</li>
<li><strong>step</strong> &#8211; Step size of the moving mirror in nm.</li>
<li><strong>order</strong> &#8211; Folding order.</li>
<li><strong>interferogram_length</strong> &#8211; Length of the interferogram from
which the phase has been computed. Useful if the phase
vectors have a lower number of points than the
interferogram: this parameter is used to correct the fit
coefficients. If None given the phase vectors are assumed to
have the same number of points as the interferogram (default
None).</li>
<li><strong>fit_order</strong> &#8211; (Optional) Order of the polynomial used to
fit the phase (default 2).</li>
<li><strong>flat_cube</strong> &#8211; (Optional) If True, data is considered to be
a flat cube so that the source delivers a high SNR at all
wavelengths. In this case no filtering is done.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A phase map is a map of the coefficients of the
polynomial fit to the phase for a given order of the
fit. The dimensions of the phase map are the same as the
dimensions of the frames of the phase cube. Values of the
zeroth order phase map are defined modulo PI. Fit_order + 1
different phase maps will be created by this method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="process.Phase.fit_phase_map">
<tt class="descname">fit_phase_map</tt><big>(</big><em>phase_map_path</em>, <em>residual_map_path</em><big>)</big><a class="headerlink" href="#process.Phase.fit_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the phase map.</p>
<p>Help remove most of the noise. This process is useful if the phase
map has been computed from astronomical data without a high SNR.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>phase_map_path</strong> &#8211; Path to the phase map</li>
<li><strong>residual_map_path</strong> &#8211; Path to the residual on phase fit</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Phase.smooth_phase_map">
<tt class="descname">smooth_phase_map</tt><big>(</big><em>phase_map_path</em><big>)</big><a class="headerlink" href="#process.Phase.smooth_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth values of a phase map.</p>
<p>This method smooth a phase map by trying to clear most of the
difference between adjacent pixels (remember that the phase is
defined modulo PI).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>phase_map_path</strong> &#8211; Path to the phase map</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="standard-class">
<h2><a class="toc-backref" href="#id8">Standard class</a><a class="headerlink" href="#standard-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="process.Standard">
<em class="property">class </em><tt class="descclassname">process.</tt><tt class="descname">Standard</tt><big>(</big><em>std_name</em>, <em>logfile_name=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#process.Standard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">orb.core.Tools</span></tt></p>
<dl class="method">
<dt id="process.Standard.__init__">
<tt class="descname">__init__</tt><big>(</big><em>std_name</em>, <em>logfile_name=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#process.Standard.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize Standard class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>std_name</strong> &#8211; Name of the standard.</li>
<li><strong>logfile_name</strong> &#8211; (Optional) Give a specific name to the
logfile (default None).</li>
<li><strong>kwargs</strong> &#8211; Kwargs are <tt class="xref py py-meth docutils literal"><span class="pre">core.Tools()</span></tt> properties.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Standard.compute_image_calibration">
<tt class="descname">compute_image_calibration</tt><big>(</big><em>images_list_path</em>, <em>filter_name</em>, <em>exp_time</em>, <em>std_coords</em>, <em>init_fwhm_arc</em>, <em>fov</em>, <em>profile_name='gaussian'</em>, <em>moffat_beta=3.5</em>, <em>prim_surf=17554</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#process.Standard.compute_image_calibration" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute &#8216;flambda&#8217; calibration coefficient for a spectrum cube
from a set of images of a standard star.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image_list_path</strong> &#8211; Path to a list of images of a standard
star.</li>
<li><strong>filter_name</strong> &#8211; Name of the filter</li>
<li><strong>exp_time</strong> &#8211; Exposition time of one frame.</li>
<li><strong>std_coords</strong> &#8211; Pixel coordinates of the standard as a
tuple [x,y]</li>
<li><strong>init_fwhm_arc</strong> &#8211; Rough FWHM of the stars in the frame in
arcseconds</li>
<li><strong>fov</strong> &#8211; Field of View of the frame</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>step</strong> &#8211; Step size in um</li>
<li><strong>step_nb</strong> &#8211; Number of steps</li>
<li><strong>profile_name</strong> &#8211; (Optional) Name of the PSF profile used
for photometry. Can be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default
&#8216;moffat&#8217;).</li>
<li><strong>moffat_beta</strong> &#8211; (Optional) Initial value of the moffat
beta parameter (default 3.5).</li>
<li><strong>prim_surf</strong> &#8211; (Optional) Surface of the primary mirror in
cm^2. Used to print the rough flux of photons. Do not change
anything to the flambda coefficient.</li>
<li><strong>verbose</strong> &#8211; (Optional) If True print more information to
check results.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Standard.get_spectrum">
<tt class="descname">get_spectrum</tt><big>(</big><em>step</em>, <em>order</em>, <em>n</em><big>)</big><a class="headerlink" href="#process.Standard.get_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return part of the standard spectrum corresponding to the
observation parameters.</p>
<p>Returned spectrum is calibrated in erg/cm^2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>step</strong> &#8211; Step size in um</li>
<li><strong>n</strong> &#8211; Number of steps</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Standard.read_calspec_fits">
<tt class="descname">read_calspec_fits</tt><big>(</big><em>file_path</em><big>)</big><a class="headerlink" href="#process.Standard.read_calspec_fits" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Read a CALSPEC fits file containing a standard spectrum and</dt>
<dd>return a tuple of arrays (wavelength, flux).</dd>
</dl>
<p>Returned wavelength axis is in A. Returned flux is in
erg/cm^2/s/A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> &#8211; Path to the Massey dat file (generally
&#8216;spXX.dat&#8217;).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="process.Standard.read_massey_dat">
<tt class="descname">read_massey_dat</tt><big>(</big><em>file_path</em><big>)</big><a class="headerlink" href="#process.Standard.read_massey_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a data file from Massey et al., Spectrophotometric
Standards (1988) and return a tuple of arrays (wavelength,
flux).</p>
<p>Returned wavelength axis is in A. Returned flux is converted
in erg/cm^2/s/A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> &#8211; Path to the Massey dat file (generally
&#8216;spXX.dat&#8217;).</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Changelog"
             >next</a> |</li>
        <li class="right" >
          <a href="orbs_module.html" title="Orbs module"
             >previous</a> |</li>
        <li><a href="index.html">Orbs 3.8.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Thomas Martin (thomas.martin.1@ulaval.ca).
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>